---
title: "CrossICC"
author: "Yu Sun"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/ysun/CrossICC_vignette")
library(CrossICC)
library(ConsensusClusterPlus)
library(tidyverse)
library(survival)
library(ggsci)
library(survminer)
library(sva)
library(RColorBrewer)
```

## Introduction

Unsupervised clustering of high-throughput molecular profiling data is widely adopted for discovering cancer subtypes. However, cancer subtypes derived from a single dataset are not usually applicable across multiple datasets from different platforms. We previously published an iterative clustering algorithm to address the issue (see this [paper](http://clincancerres.aacrjournals.org/content/21/4/870.long)), but its use was hampered due to lack of implementation. In this work, we presented CrossICC that was an R package implementation of this method. Moreover, many new features were added to improve the performance of the algorithm. Briefly, [CrossICC](https://github.com/bioinformatist/CrossICC) utilizes an iterative strategy to derive the optimal gene set and cluster number from consensus similarity matrix generated by consensus clustering. [CrossICC](https://github.com/bioinformatist/CrossICC) is able to deal with multiple cross platform datasets so that requires no between-dataset normalizations. This package also provides abundant functions to help users visualize the identified subtypes and evaluate the subtyping performance. Specially, many cancer-related analysis methods are embedded to facilitate the clinical translation of the identified cancer subtypes.  

There are two modes for the integration of clusters derived cross-platform datasets: `cluster`  mode and `sample` mode. For `cluster` mode, samples from each platform are clustered separately and centroids of each sub cluster derived from [ConsensusClusterPlus](https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.htm) were further clustered to generate super cluster. This process avoided removing batch effect across platforms. The details step by step illustration of this algorithm can be found in our previous published [paper](http://clincancerres.aacrjournals.org/content/early/2014/12/09/1078-0432.ccr-14-2481) and our recent submitted paper[coming soon]. For `sample` mode, sub clusters were firstly derived from [ConsensusClusterPlus](https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.htm) in each platform. We then calculated correlation coefficient between samples and centroids of clusters to get a new feature vector of each samples. Based on this new matrix, samples were divided into new clusters.

## Visualize your result in a shiny app 

By default, there is a `shiny=TRUE` option in `CrossICC()` function. This means that each running result can be automaticly reloading into a shiny app for users to visualize there analysis result. Since interactive analysis need graphic interface, we strongly recommanded users run there result in GUI version of R environment. R studio or R gui console e.g. On the other hand, when leave default shiny option unchanged, `CrossICC()` will not return a crossICC object that stored all analysis result. Instead, you will find a rds file in your home folder named `~/CrossICC.object.rds`. To get the result object, you can simplely input `data.t<-readRDS("~/CrossICC.object.rds")` to fetch the result. The detailed usage of shiny app will be found in our shiny web page. An alternative way to launch the shiny app is to use `CrossICC::runshiny()` function. Afterthat, you can uploading `.rds` file previously generated to explore your result. 

## A case: Breast Cancer datasets analysis

<!-- TODO: Plz fill this part -->
Breast cancer is...
The data comes from...

### Download datasets

The tutorial uses 7 large datasets. You need run commands as below to download them first:

```shell
# TODO: Plz add data explaination with comments, or add a new paragraph below
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/BRCA_TCGA.RData?raw=true
aria2c https://raw.githubusercontent.com/xiucaikun/CrossICCtest/master/data/BreastCancer.GEO-TCGA-Survival.txt
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/GPL13667_GSE53031.exp.RData?raw=true
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/GPL13667_GSE65095.exp.RData?raw=true
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/GPL570_GSE31448.exp.RData?raw=true
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/GPL6098_GSE22219.exp.RData?raw=true
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/GPL6244_GSE37751.exp.RData?raw=true
aria2c https://github.com/xiucaikun/CrossICCtest/blob/master/data/GPL6883_GSE45725.exp.RData?raw=true
```

### Pre-load functions

The tutorial uses several pre-defined R function for pre-process data and plotting. You need to load them before you run comming examples.

```{r}
# If has connection problems, download it then try source locally again
# source('https://raw.githubusercontent.com/xiucaikun/CrossICCtest/master/Rcode/plot.functions.R')
# setwd("/home/ysun/CrossICC_vignette")
source('plot.functions.R')
```

### A Breast Cancer analysis case with CrossICC

#### Data preparation

Change the R working directory to the folder in which you stored previously downloaded 7 datasets using `setwd()` function.

To run `CrossICC` or `ConsensusClusterPlus`, you need a list of intergrated expression matrices as well as samples and batch information. 

```{r}
testfiles <- c("GPL6883_GSE45725.exp.RData",  "GPL6098_GSE22219.exp.RData",
               "GPL13667_GSE65095.exp.RData", "GPL13667_GSE53031.exp.RData",
               "GPL6244_GSE37751.exp.RData",  "GPL570_GSE31448.exp.RData",
               "BRCA_TCGA.RData")

datalist <- vector("list", length = 7)
for(i in 1:length(testfiles)){
    load(testfiles[i])
    GEO_matrix0 <- codingExp
    datalist[[i]] <- as.matrix(codingExp)
    GEO_matrix0_mad <- apply(GEO_matrix0, 1, mad)
    GEO_matrix0 <-  GEO_matrix0[GEO_matrix0_mad > 0.1, ]
    
    if(i == 1){GEO_matrix <- GEO_matrix0
    batchlist <- as.character(rep(i, ncol(GEO_matrix0)))
    patientsID <- colnames(GEO_matrix0)
    }else{
        GEO_matrix <- srbind(GEO_matrix, GEO_matrix0)
        batchlist <- c(batchlist, rep(i, ncol(GEO_matrix0)))
        patientsID <- c(patientsID, colnames(GEO_matrix0))
    }
}

patientsID_batch <- data.frame(samples = patientsID,
                               batch = batchlist,
                               row.names = patientsID,
                               stringsAsFactors = FALSE)
brcaGEOTCGA_file7 <- read.delim("BreastCancer.GEO-TCGA-Survival.txt", sep = "\t", stringsAsFactors = FALSE)
row.names(brcaGEOTCGA_file7) <- brcaGEOTCGA_file7$GSM
```

#### Batch effect? How much impact?

To evaluate the impact of batch effect during clustering process, we first perform PCA and ConsensusClusterPlus without removing batch effect.

```{r}
NotRemoveBatch <- ConsensusClusterPlus(as.matrix(GEO_matrix),
                                       maxK = 10,
                                       reps = 100,
                                       pItem = 0.8,
                                       pFeature = 1,
                                       plot = 'png',
                                       title = "NotRemoveBatch",
                                       distance = "pearson",
                                       clusterAlg = "hc")

# k = 10 shows the best CDF result, but to balance the relationship between efficacy and number of each group, we choose the result of k = 6 to show
NotRemoveBatchResultClass <- data.frame(group = NotRemoveBatch[[6]]$consensusClass) %>% rownames_to_column(var = "sample")

# Survival analysis
BRCAsurvival_NRB <- merge(x = NotRemoveBatchResultClass, y = brcaGEOTCGA_file7, by.x = "sample", by.y = "GSM") %>%
    mutate(Cluster = paste("Cluster", group, sep = "")) %>%
    filter(!Cluster %in% c("Cluster2", "Cluster6"))

BRCAsurvival_NRB.Plot <- consensusSurvival(SurvivalData = BRCAsurvival_NRB)
print(BRCAsurvival_NRB.Plot, newpage = FALSE)
```

```{r}
notRemoveBatchPCA <- prcomp(t(GEO_matrix), scale. = TRUE)
NRB_matrix <- notRemoveBatchPCA$x
NRBpcaPlotData <- data.frame(NRB_matrix[, c(1:2)],
                             Batch = batchlist,
                             ConsensusGroup = as.character(NotRemoveBatchResultClass$group),
                             stringsAsFactors = FALSE)

NotRemoveBatchPCAplot <- ggplot()+theme_bw()+
                        geom_point(data = NRBpcaPlotData,
                                   aes(x = PC1, y = PC2, color = Batch, shape = ConsensusGroup), size =2)+
                        scale_colour_nejm()+
                        xlab("PC1(76.2% explained var.)")+ylab("PC2(7.1% explained var.)")+
                        theme(axis.text.x = element_text(angle=0, hjust=0.5, vjust=0.8, size=14, face="plain"),
                              axis.text.y = element_text(angle=0, hjust=0.8, vjust=0.5, size=14, face="plain"),
                              axis.title.y = element_text(angle=90, vjust=0.8, size=14, face="plain"),
                              axis.title.x = element_text(angle=0, size=14, face="plain"),
                              legend.title = element_text(angle=0, hjust=0.8, vjust=0.8, size=13, face="plain"),
                              legend.text = element_text(angle=0, hjust=0.8, vjust=0.8, size=12.5, face="plain"),
                              legend.position = c(0.8, 0.6),
                              legend.background = element_blank(),
                              legend.key = element_blank())

print(NotRemoveBatchPCAplot)
```

<!-- TODO: explain the results here. -->

Correspondingly, we also tried to remove the batch effect and then ran ConcensusClusterPlus again.

```{r}
batch <- as.factor(batchlist)
RemoveBatchMatrix <- ComBat(as.matrix(GEO_matrix), batch)

RemoveBatch <- ConsensusClusterPlus(as.matrix(RemoveBatchMatrix),
                                    maxK = 10,
                                    reps = 100,
                                    pItem = 0.8,
                                    pFeature = 1,
                                    plot = 'png',
                                    title = "RemoveBatch",
                                    distance = "pearson",
                                    clusterAlg="hc")
# When k = 2, show the best CDF value
RemoveBatchResultClass <- data.frame(group = RemoveBatch[[2]]$consensusClass) %>% rownames_to_column(var = "sample")

# Survival analysis
BRCAsurvival_RB <- merge(x = RemoveBatchResultClass, y = brcaGEOTCGA_file7, by.x = "sample", by.y = "GSM") %>%
    mutate(Cluster = paste("Cluster", group, sep = ""))

BRCAsurvival_RB.Plot <- consensusSurvival(SurvivalData = BRCAsurvival_RB)
print(BRCAsurvival_RB.Plot, newpage = FALSE)
```

```{r}
RemoveBatchPCA <- prcomp(t(RemoveBatchMatrix), scale. = TRUE)
RB_matrix <- RemoveBatchPCA$x
RBpcaPlotData <- data.frame(RB_matrix[, c(1:2)],
                            Batch = batchlist,
                            ConsensusGroup = as.character(RemoveBatchResultClass$group),
                            stringsAsFactors = FALSE)

RemoveBatchPCAplot <- ggplot()+
                        theme_bw()+
                        geom_point(data = RBpcaPlotData,
                                   aes(x = PC1, y = PC2, color = Batch, shape = ConsensusGroup), size =2)+
                        scale_colour_nejm()+
                        xlab("PC1(8.3% explained var.)")+ylab("PC2(6.9% explained var.)")+
                        theme(axis.text.x = element_text(angle=0, hjust=0.5, vjust=0.8, size=14, face="plain"),
                              axis.text.y = element_text(angle=0, hjust=0.8, vjust=0.5, size=14, face="plain"),
                              axis.title.y = element_text(angle=90, vjust=0.8, size=14, face="plain"),
                              axis.title.x = element_text(angle=0, size=14, face="plain"),
                              legend.title = element_text(angle=0, hjust=0.8, vjust=0.8, size=13, face="plain"),
                              legend.text = element_text(angle=0, hjust=0.8, vjust=0.8, size=12.5, face="plain"),
                              legend.position = c(0.85, 0.7),
                              legend.background = element_blank(),
                              legend.key = element_blank())
print(RemoveBatchPCAplot)
```

#### With CrossICC, there is no need to remove batch effects anymore

Before using CrossICC analysis, let's first have a look at the variability of these data by observing the contribution of each principal component of each dataset.

```{r}
# Principal component analysis for merged dataset
importancedata <- summary(RemoveBatchPCA)$importance
importancedata <- t(importancedata)[1:10,]
importancedata <- data.frame(importancedata, comp = rownames(importancedata), Sets = "Total")
importancedata$Proportion.of.Variance = importancedata$Proportion.of.Variance*100

ggplot(importancedata, aes(x = factor(importancedata$comp, levels = paste("PC", 1:10, sep = "")),
                                             y = Proportion.of.Variance,
                                             group = Sets, color = Sets))+
    theme_classic()+geom_line(show.legend = FALSE)+geom_point(size = 3, show.legend = FALSE)+
    xlab("Components")+ ylab("Proportion of Variance (%)")+
    theme(axis.text = element_text(angle = 0, size = 14, face = "plain"),
          axis.title = element_text(angle = 0, size = 14, face = "plain"))+
    scale_color_jco()


# Principal component analysis for each dataset
datatestImpTotal <- data.frame()
for(i in 1:7){
    datatest <- datalist[[i]]
    removeGene <- rownames(datatest)[which(apply(datatest, 1, var) == 0)]
    datatest <- datatest[!(rownames(datatest) %in% removeGene), ]
    datatestPCA <- prcomp(t(as.matrix(datatest)), scale. = TRUE)
    datatestImp <- summary(datatestPCA)$importance
    datatestImp <- t(datatestImp)[1:10,]
    datatestImp <- data.frame(datatestImp, comp = rownames(datatestImp), Sets = paste("Dataset", i, sep = ""))
    datatestImpTotal <- rbind(datatestImp, datatestImpTotal)
}

datatestImpTotal$Proportion.of.Variance <- datatestImpTotal$Proportion.of.Variance*100
setlevels <- c("Total", paste("Dataset", 1:10, sep = ""))
All2show <- rbind(importancedata, datatestImpTotal)
ggplot(All2show, aes(x = factor(All2show$comp, levels = paste("PC", 1:10, sep = "")),
                                        y = Proportion.of.Variance,
                                        group = factor(All2show$Sets, levels = setlevels),
                                        color = factor(All2show$Sets, levels = setlevels)))+
    theme_classic()+geom_line()+geom_point(size = 3)+
    xlab("Components")+ ylab("Proportion of Variance (%)")+labs(color = "Sets")+
    theme(axis.text = element_text(color = "black", angle = 0, size = 14, face = "plain"),
          axis.title = element_text(angle = 0, size = 14, face = "plain"),
          legend.title = element_text(angle = 0, size = 13, face = "plain"),
          legend.text = element_text(angle = 0, size = 13, face = "plain"))+
    scale_color_jco()
```

<!-- TODO: detailed explaination of these PCA results -->

Then use CrossICC for clustering now, without any removing batch effect manipulation.

```{r}
dir.create('CrossICC_result', showWarnings = FALSE)
CrossICCtestRes <- CrossICC(datalist,
                            max.iter = 100, cross = "cluster",
                            fdr.cutoff = 0.1, ebayes.cutoff = 0.1,
                            filter.cutoff = 0.1, n.platform = 4, use.shiny = FALSE)

# get cluster result of CrossICC #
CrossICCclusterResult <- data.frame(cluster = CrossICC::summary.CrossICC(CrossICCtestRes)$clusters, stringsAsFactors = FALSE) %>%
                         rownames_to_column(var = "sampleid") %>%
                         dplyr::filter(cluster != "") %>%
                         mutate(Cluster = paste("Cluster", cluster, sep = ""))

CrossICCclusterResult <- merge(x = CrossICCclusterResult, y = brcaGEOTCGA_file7, by.x = "sampleid", by.y = "GSM") %>%
                         dplyr::filter(!Cluster %in% c("Cluster8", "Cluster3", "Cluster9"))


### plot CrossICC result survival curve ###
breast_survivalGEOTCGA_CrossICC_plot <- consensusSurvival(SurvivalData = CrossICCclusterResult)
print(breast_survivalGEOTCGA_CrossICC_plot, newpage = FALSE)
```

Also perform a PCA:

```{r}
# PCA analysis of CrossICC result
CrossICCMatrixTotal <- GEO_matrix[, CrossICCclusterResult$sampleid]
CrossICCpca <- prcomp(t(CrossICCMatrixTotal), scale. = TRUE)

CrossICC.PCA.PlotData <- CrossICCpca$x %>% as.data.frame() %>% .[, c(1:3)]

patientsIDbatchCrossICC <- patientsID_batch[rownames(CrossICC.PCA.PlotData), ]

CrossICC.PCA.PlotData <- mutate(CrossICC.PCA.PlotData,
                                Batch = as.character(patientsIDbatchCrossICC$batch),
                                CrossICC.Cluster = CrossICCclusterResult$Cluster)

ggplot()+theme_bw()+
    geom_point(data = CrossICC.PCA.PlotData,
               aes(x = PC1, y = PC2, color = Batch, shape = CrossICC.Cluster), size =2)+
    scale_colour_nejm()+
    xlab("PC1(76.2% explained var.)")+ylab("PC2(7.1% explained var.)")+
    theme(axis.text.x = element_text(angle=0, hjust=0.5, vjust=0.8, size=14, face="plain"),
          axis.text.y = element_text(angle=0, hjust=0.8, vjust=0.5, size=14, face="plain"),
          axis.title.y = element_text(angle=90, vjust=0.8, size=14, face="plain"),
          axis.title.x = element_text(angle=0, size=14, face="plain"),
          legend.title = element_text(angle=0, hjust=0.8, vjust=0.8, size=13, face="plain"),
          legend.text = element_text(angle=0, hjust=0.8, vjust=0.8, size=12.5, face="plain"),
          legend.position = c(0.8, 0.7),
          legend.background = element_blank(),
          legend.key = element_blank())
```

<!-- TODO: add description of PCA results,  comparing to previous PCA results -->

<!-- TODO: add description for this step -->
Finally, let's show the ...

```{r}
# Plot heatmap for each matrix by signature genes
for(k in 1:7){
    plot.matrix<-as.data.frame(CrossICCtestRes$platforms[[k]])
    if(class(CrossICCtestRes$clusters$clusters)=="list"){
        cluster.table<-CrossICCtestRes$clusters$clusters[[k]]
    }else{
        cluster.table<-CrossICCtestRes$clusters$clusters
    }
    gsig<-CrossICCtestRes$gene.order[[k]]
    plot_expression_heatmap_with_cluster(plot.matrix,cluster.table,gsig, cluster_row = FALSE, showRowname = FALSE)
}
```

<!-- TODO: give a definition of signature genes of CrossICC here, and add description for these heatmaps -->
